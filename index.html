<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Tic-Tac-Toe | Minimax + Alpha-Beta</title>

  <!-- Optional fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">

  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    body{
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background:radial-gradient(circle at top,#3b2a1a 0,#160c05 40%,#050301 100%);
      font-family:"Roboto",system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      color:#f9fafb;
    }
    .game-shell{
      width:720px;
      max-width:100%;
      padding:24px 28px 26px;
      border-radius:28px;
      background:linear-gradient(135deg,#050506,#17110c);
      box-shadow:0 28px 70px rgba(0,0,0,.9),inset 0 0 0 1px rgba(255,255,255,.03);
      position:relative;
      z-index:1;
    }
    .inner-frame{
      border-radius:24px;
      padding:20px 22px 22px;
      background-image:linear-gradient(125deg,#c58a49 0%,#8b5725 35%,#5a3313 70%,#c58a49 100%);
      background-size:260px 260px;
      box-shadow:inset 0 0 0 1px rgba(0,0,0,.45),inset 0 2px 0 rgba(255,255,255,.15),0 18px 40px rgba(0,0,0,.75);
    }
    .header{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      margin-bottom:12px;
    }
    .title-block{text-align:left;}
    .title-main{
      font-family:"Bebas Neue",system-ui;
      letter-spacing:.16em;
      font-size:30px;
      color:#fff;
      text-shadow:0 2px 0 rgba(0,0,0,.8);
    }
    .title-sub{
      margin-top:2px;
      font-size:11px;
      color:#fde68a;
      letter-spacing:.22em;
      text-transform:uppercase;
    }
    .size-select-wrap{font-size:11px;text-align:right;}
    .size-label{
      text-transform:uppercase;
      letter-spacing:.18em;
      color:#fef3c7;
      margin-bottom:4px;
      font-family:"Bebas Neue",system-ui;
      font-size:12px;
    }
    .size-select{
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(15,23,42,.6);
      background:rgba(0,0,0,.35);
      color:#fefce8;
      font-size:11px;
      outline:none;
    }

    .layout{
      display:grid;
      grid-template-columns:1.05fr .95fr;
      gap:18px;
      align-items:stretch;
    }

    /* LEFT: board card */
    .board-card{
      border-radius:22px;
      padding:14px 14px 16px;
      background:radial-gradient(circle at top,#3d2614,#2a170b 55%,#1a0f07 100%);
      box-shadow:inset 0 0 0 1px rgba(0,0,0,.55),0 12px 26px rgba(0,0,0,.8);
    }
    .banner{
      text-align:center;
      margin-bottom:6px;
      font-family:"Bebas Neue",system-ui;
      letter-spacing:.16em;
      font-size:18px;
      color:#fef9c3;
      text-transform:uppercase;
      text-shadow:0 1px 0 rgba(0,0,0,.8);
    }
    #timerText{
      text-align:center;
      font-size:11px;
      margin-bottom:6px;
      color:#facc15;
      letter-spacing:.10em;
    }
    .board{
      display:grid;
      gap:8px;
    }
    .cell{
      width:100%;
      aspect-ratio:1/1;
      border-radius:16px;
      border:1px solid rgba(15,10,5,.9);
      background:linear-gradient(150deg,#7a4b21,#4c2a12);
      box-shadow:
        inset 0 3px 3px rgba(255,255,255,.28),
        inset 0 -5px 7px rgba(0,0,0,.8),
        0 7px 14px rgba(0,0,0,.95);
      font-size:52px;
      font-weight:700;
      color:#f9fafb;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      text-shadow:0 3px 0 rgba(0,0,0,.85),0 9px 18px rgba(0,0,0,.95);
      transition:transform .12s ease,box-shadow .12s ease,border-color .12s ease,filter .12s ease;
    }
    .cell:hover{
      transform:translateY(-2px);
      box-shadow:
        inset 0 3px 3px rgba(255,255,255,.28),
        inset 0 -5px 7px rgba(0,0,0,.85),
        0 13px 24px rgba(0,0,0,.98);
      border-color:#f97316;
      filter:brightness(1.04);
    }
    .cell.disabled{
      cursor:default;
      opacity:.82;
      transform:none;
      box-shadow:
        inset 0 3px 3px rgba(255,255,255,.25),
        inset 0 -5px 6px rgba(0,0,0,.8),
        0 6px 16px rgba(0,0,0,.92);
    }
    .cell.X{color:#f97373;}
    .cell.O{color:#e5e7eb;}
    .cell.win{
      box-shadow:0 0 0 3px #facc15,0 0 18px rgba(250,204,21,.85);
    }
    .cell.hint{
      box-shadow:0 0 0 2px #38bdf8,0 0 14px rgba(56,189,248,.9);
    }

    /* RIGHT: stats card */
    .stats-card{
      border-radius:22px;
      padding:14px 14px 16px;
      background:radial-gradient(circle at top,#18151b,#05040a 70%);
      box-shadow:inset 0 0 0 1px rgba(15,23,42,.7),0 12px 26px rgba(0,0,0,.9);
      font-size:12px;
    }
    .stats-title{
      font-family:"Bebas Neue",system-ui;
      text-align:center;
      text-transform:uppercase;
      letter-spacing:.22em;
      font-size:14px;
      color:#e5e7eb;
      margin-bottom:4px;
    }
    .chip{
      margin:4px auto 10px;
      border-radius:999px;
      padding:5px 10px;
      border:1px solid rgba(250,204,21,.8);
      background:rgba(0,0,0,.5);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.12em;
      color:#fde68a;
    }
    .metrics-grid{
      display:grid;
      grid-template-columns:repeat(2,1fr);
      gap:7px;
      margin-bottom:6px;
    }
    .metric-box{
      border-radius:12px;
      padding:6px 8px;
      background:#020617;
      box-shadow:inset 0 0 0 1px rgba(148,163,184,.4);
    }
    .metric-label{
      font-size:10px;
      text-transform:uppercase;
      letter-spacing:.10em;
      color:#e5e7ebc0;
      margin-bottom:2px;
    }
    .metric-value{
      font-size:16px;
      font-variant-numeric:tabular-nums;
      font-weight:600;
      color:#facc15;
    }
    .metric-wide{grid-column:span 2;}
    .note{
      font-size:10px;
      color:#9ca3afb8;
      margin-top:4px;
    }

    /* Scoreboard */
    .scoreboard{
      margin-top:10px;
      padding:6px 8px;
      border-radius:12px;
      background:#020617;
      box-shadow:inset 0 0 0 1px rgba(148,163,184,.35);
      font-size:11px;
    }
    .score-title{
      text-transform:uppercase;
      letter-spacing:.16em;
      font-family:"Bebas Neue",system-ui;
      font-size:12px;
      color:#e5e7eb;
      margin-bottom:4px;
      text-align:center;
    }
    .score-row{
      display:flex;
      justify-content:space-between;
      padding:2px 0;
    }
    .score-label{color:#e5e7ebb3;}
    .score-value{
      font-variant-numeric:tabular-nums;
      font-weight:600;
      color:#facc15;
    }
    .history-list{
      max-height:90px;
      overflow-y:auto;
      font-size:10px;
      line-height:1.3;
      color:#e5e7ebd0;
    }
    .history-list div:nth-child(odd){opacity:.95;}
    .history-list div:nth-child(even){opacity:.8;}

    .btn-row{
      margin-top:10px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .reset-btn{
      border:none;
      border-radius:999px;
      padding:7px 16px;
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.16em;
      font-weight:600;
      background:linear-gradient(135deg,#f97316,#fb923c);
      color:#111827;
      cursor:pointer;
      box-shadow:0 8px 18px rgba(0,0,0,.95);
    }
    .reset-btn.secondary{
      background:linear-gradient(135deg,#0f172a,#1f2937);
      color:#e5e7eb;
      box-shadow:0 4px 10px rgba(0,0,0,.9);
      padding:7px 12px;
      font-weight:500;
      letter-spacing:.12em;
    }
    .reset-btn:active{
      transform:translateY(1px);
      box-shadow:0 4px 10px rgba(0,0,0,.95);
    }
    .info{
      font-size:9.5px;
      color:#e5e7ebb8;
      flex:1 1 100%;
    }
    .status-line{
      font-size:11px;
      margin-top:4px;
      color:#e5e7eb;
    }
    .sound-toggle{
      margin-top:6px;
      font-size:10px;
      color:#e5e7ebb8;
      display:flex;
      justify-content:flex-end;
    }
    .sound-toggle input{margin-right:4px;}

    .footer{
      margin-top:12px;
      text-align:center;
      font-family:"Bebas Neue",system-ui;
      text-transform:uppercase;
      font-size:18px;
      letter-spacing:.26em;
      color:#fff7ed;
      text-shadow:0 2px 0 rgba(0,0,0,.8);
    }
    @media(max-width:760px){
      .layout{grid-template-columns:1fr;row-gap:14px;}
      .info{flex:1 1 100%;}
    }

    /* Symbol select overlay */
    .symbol-overlay{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.6);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:10;
    }
    .symbol-modal{
      background:#111827;
      border-radius:18px;
      padding:18px 22px 16px;
      box-shadow:0 18px 40px rgba(0,0,0,.9);
      border:1px solid rgba(148,163,184,.4);
      text-align:center;
      max-width:260px;
      width:90%;
    }
    .symbol-title{
      font-family:"Bebas Neue",system-ui;
      text-transform:uppercase;
      letter-spacing:.18em;
      font-size:16px;
      color:#facc15;
      margin-bottom:4px;
    }
    .symbol-sub{
      font-size:11px;
      color:#e5e7ebc0;
      margin-bottom:10px;
    }
    .symbol-buttons{
      display:flex;
      gap:10px;
      justify-content:center;
    }
    .symbol-btn{
      border:none;
      border-radius:999px;
      padding:8px 18px;
      font-size:12px;
      font-weight:600;
      cursor:pointer;
      text-transform:uppercase;
      letter-spacing:.14em;
      box-shadow:0 8px 18px rgba(0,0,0,.9);
    }
    .symbol-btn-x{
      background:linear-gradient(135deg,#f97373,#fb7185);
      color:#111827;
    }
    .symbol-btn-o{
      background:linear-gradient(135deg,#e5e7eb,#f9fafb);
      color:#111827;
    }
    .symbol-btn:active{
      transform:translateY(1px);
      box-shadow:0 4px 10px rgba(0,0,0,.9);
    }
    .hidden{display:none;}
  </style>
</head>
<body>

  <!-- Symbol selection overlay -->
  <div class="symbol-overlay" id="symbolOverlay">
    <div class="symbol-modal">
      <div class="symbol-title">CHOOSE YOUR SYMBOL</div>
      <div class="symbol-sub">Select whether you want to play as X or O.</div>
      <div class="symbol-buttons">
        <button class="symbol-btn symbol-btn-x" data-symbol="X">Play as X</button>
        <button class="symbol-btn symbol-btn-o" data-symbol="O">Play as O</button>
      </div>
    </div>
  </div>

  <div class="game-shell">
    <div class="inner-frame">
      <header class="header">
        <div class="title-block">
          <div class="title-main">TIC-TAC-TOE</div>
          <div class="title-sub">MINIMAX · ALPHA–BETA PRUNING</div>
        </div>
        <div class="size-select-wrap">
          <div class="size-label">BOARD SIZE</div>
          <select id="boardSize" class="size-select">
            <option value="3" selected>3 × 3</option>
            <option value="4">4 × 4</option>
          </select>
        </div>
      </header>

      <div class="layout">
        <!-- LEFT: BOARD -->
        <section class="board-card">
          <div class="banner" id="bannerText">Your turn · place your O</div>
          <div id="timerText">Time left: 10s</div>
          <div class="board" id="board"></div>
        </section>

        <!-- RIGHT: STATS -->
        <aside class="stats-card">
          <div class="stats-title">Search Statistics</div>
          <div class="chip" id="chipText">Waiting for your move</div>

          <div class="metrics-grid">
            <div class="metric-box">
              <div class="metric-label">Pure Minimax Nodes</div>
              <div class="metric-value" id="nodesPure">0</div>
            </div>
            <div class="metric-box">
              <div class="metric-label">Alpha-Beta Nodes</div>
              <div class="metric-value" id="nodesAB">0</div>
            </div>
            <div class="metric-box metric-wide">
              <div class="metric-label">Branches Pruned (Alpha-Beta)</div>
              <div class="metric-value" id="nodesPruned">0</div>
            </div>
          </div>

          <div class="note">
            Same best move, but alpha–beta pruning explores fewer states than pure minimax by cutting branches that cannot affect the final decision.
          </div>

          <!-- SCOREBOARD -->
          <div class="scoreboard">
            <div class="score-title">Scoreboard</div>
            <div class="score-row">
              <span class="score-label" id="labelHuman">Human Wins (O)</span>
              <span class="score-value" id="scoreHuman">0</span>
            </div>
            <div class="score-row">
              <span class="score-label" id="labelAI">AI Wins (X)</span>
              <span class="score-value" id="scoreAI">0</span>
            </div>
            <div class="score-row">
              <span class="score-label">Draws</span>
              <span class="score-value" id="scoreDraws">0</span>
            </div>
          </div>

          <!-- MOVE HISTORY -->
          <div class="scoreboard">
            <div class="score-title">Move History</div>
            <div class="history-list" id="historyList">No moves yet.</div>
          </div>

          <div class="btn-row">
            <button class="reset-btn" id="resetBtn">Reset Game</button>
            <button class="reset-btn secondary" id="hintBtn">Hint</button>
            <button class="reset-btn secondary" id="undoBtn">Undo</button>
            <div class="info" id="infoText">
              You are <strong>O</strong>. AI is <strong>X</strong><br/>
              using Minimax + Alpha–Beta.
            </div>
          </div>

          <div class="sound-toggle">
            <label><input type="checkbox" id="soundToggle" checked>Sound on</label>
          </div>

          <div class="status-line" id="statusText">Game in progress…</div>
        </aside>
      </div>

      <div class="footer" id="footerText">Place 3 in a row!</div>
    </div>
  </div>

  <script>
    const EMPTY = "";

    let size = 3;
    let board = [];
    let gameOver = false;
    let currentPlayer = EMPTY; // will be set to humanSymbol once game starts

    // symbols (changeable by user)
    let humanSymbol = "O";
    let aiSymbol = "X";

    // scores
    let humanWins = 0;
    let aiWins = 0;
    let draws = 0;

    // timer
    let turnTimer = null;
    let timeLeft = 10;
    let missCount = 0; // number of timeouts (max 2)

    // move history
    let moveHistory = [];

    // sound
    let soundEnabled = true;
    let audioCtx = null;

    const boardEl = document.getElementById("board");
    const bannerText = document.getElementById("bannerText");
    const chipText = document.getElementById("chipText");
    const statusText = document.getElementById("statusText");
    const footerText = document.getElementById("footerText");
    const nodesPureEl = document.getElementById("nodesPure");
    const nodesABEl = document.getElementById("nodesAB");
    const nodesPrunedEl = document.getElementById("nodesPruned");
    const resetBtn = document.getElementById("resetBtn");
    const boardSizeSelect = document.getElementById("boardSize");
    const timerText = document.getElementById("timerText");

    const scoreHumanEl = document.getElementById("scoreHuman");
    const scoreAIEl = document.getElementById("scoreAI");
    const scoreDrawsEl = document.getElementById("scoreDraws");
    const labelHuman = document.getElementById("labelHuman");
    const labelAI = document.getElementById("labelAI");
    const infoText = document.getElementById("infoText");

    const historyList = document.getElementById("historyList");
    const hintBtn = document.getElementById("hintBtn");
    const undoBtn = document.getElementById("undoBtn");
    const soundToggle = document.getElementById("soundToggle");

    const symbolOverlay = document.getElementById("symbolOverlay");

    // --- sound helpers ---
    function getAudioCtx(){
      if (!audioCtx) {
        const AC = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AC();
      }
      return audioCtx;
    }
    function playBeep(freq, duration){
      if (!soundEnabled) return;
      try{
        const ctx = getAudioCtx();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = "sine";
        osc.frequency.value = freq;
        osc.connect(gain);
        gain.connect(ctx.destination);
        const now = ctx.currentTime;
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        osc.start(now);
        osc.stop(now + duration);
      }catch(e){}
    }
    function playMoveSound(){ playBeep(600,0.08); }
    function playWinSound(){ playBeep(420,0.25); }
    function playLoseSound(){ playBeep(200,0.25); }
    function playDrawSound(){ playBeep(300,0.2); }

    soundToggle.addEventListener("change", () => {
      soundEnabled = soundToggle.checked;
    });

    // --- symbol selection handlers ---
    document.querySelectorAll(".symbol-btn").forEach(btn => {
      btn.addEventListener("click", () => {
        const chosen = btn.dataset.symbol;
        humanSymbol = chosen;
        aiSymbol = chosen === "X" ? "O" : "X";
        symbolOverlay.classList.add("hidden");
        resetGame(true); // new side -> reset scores too
      });
    });

    boardSizeSelect.addEventListener("change", () => {
      size = parseInt(boardSizeSelect.value, 10);
      resetGame(false); // board change, scores keep
    });

    function updateSymbolTexts() {
      labelHuman.textContent = `Human Wins (${humanSymbol})`;
      labelAI.textContent = `AI Wins (${aiSymbol})`;
      infoText.innerHTML = `You are <strong>${humanSymbol}</strong>. AI is <strong>${aiSymbol}</strong><br/>using Minimax + Alpha–Beta.`;
    }

    function updateScoreboard() {
      scoreHumanEl.textContent = humanWins;
      scoreAIEl.textContent = aiWins;
      scoreDrawsEl.textContent = draws;
    }

    function indexToRowCol(i){
      return {row: Math.floor(i/size), col: i%size};
    }

    function renderHistory(){
      if (!moveHistory.length){
        historyList.textContent = "No moves yet.";
        return;
      }
      historyList.innerHTML = "";
      moveHistory.forEach((m, idx) => {
        const rc = indexToRowCol(m.index);
        const div = document.createElement("div");
        div.textContent = `${idx+1}. ${m.player} → (${rc.row+1}, ${rc.col+1})`;
        historyList.appendChild(div);
      });
    }

    function recordMove(player, index){
      moveHistory.push({player, index});
      renderHistory();
    }

    function initBoard() {
      board = Array(size * size).fill(EMPTY);
      boardEl.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
      boardEl.innerHTML = "";
      for (let i = 0; i < board.length; i++) {
        const cell = document.createElement("button");
        cell.className = "cell";
        cell.dataset.index = i.toString();
        cell.addEventListener("click", onCellClick);
        boardEl.appendChild(cell);
      }
      if (!currentPlayer) currentPlayer = humanSymbol;
      updateTexts();
    }

    function updateTexts() {
      footerText.textContent = size === 3 ? "Place 3 in a row!" : "Place 4 in a row!";
      if (gameOver) return;
      bannerText.textContent =
        currentPlayer === humanSymbol ? "Your turn · place your " + humanSymbol
                                      : "AI thinking · " + aiSymbol + " to move";
      chipText.textContent =
        currentPlayer === humanSymbol ? "Waiting for your move" : "Minimax is searching…";
      statusText.textContent = size === 3
        ? "3×3 board · perfect Minimax search."
        : "4×4 board · depth-limited Minimax for faster play.";
    }

    function render() {
      const cells = boardEl.children;
      for (let i = 0; i < board.length; i++) {
        const v = board[i];
        const cell = cells[i];

        // preserve win / hint classes
        const hadWin = cell.classList.contains("win");
        const hadHint = cell.classList.contains("hint");

        let cls = "cell";
        if (v) cls += " " + v;
        if (gameOver) cls += " disabled";
        if (hadWin) cls += " win";
        if (hadHint) cls += " hint";
        cell.className = cls;

        cell.textContent = v;
      }
      updateTexts();
    }

    function onCellClick(e) {
      if (symbolOverlay && !symbolOverlay.classList.contains("hidden")) return; // must choose symbol first
      if (gameOver || currentPlayer !== humanSymbol) return;
      const idx = parseInt(e.currentTarget.dataset.index, 10);
      if (board[idx] !== EMPTY) return;

      clearInterval(turnTimer);

      board[idx] = humanSymbol;
      recordMove(humanSymbol, idx);
      playMoveSound();
      currentPlayer = aiSymbol;
      render();

      const w = winner(board);
      if (w) {
        finishGame(w);
      } else {
        aiMove();
      }
    }

    function availableMoves(b) {
      const moves = [];
      for (let i = 0; i < b.length; i++) if (b[i] === EMPTY) moves.push(i);
      return moves;
    }

    function winner(b) {
      const lines = [];
      for (let r = 0; r < size; r++) {
        const row = [];
        const col = [];
        for (let c = 0; c < size; c++) {
          row.push(r * size + c);
          col.push(c * size + r);
        }
        lines.push(row, col);
      }
      const d1 = [];
      const d2 = [];
      for (let i = 0; i < size; i++) {
        d1.push(i * (size + 1));
        d2.push((i + 1) * (size - 1));
      }
      lines.push(d1, d2);

      for (const line of lines) {
        const first = b[line[0]];
        if (!first) continue;
        if (line.every(i => b[i] === first)) return first;
      }
      if (!b.includes(EMPTY)) return "DRAW";
      return null;
    }

    function getWinningLine(b){
      const lines = [];
      for (let r = 0; r < size; r++) {
        const row = [];
        const col = [];
        for (let c = 0; c < size; c++) {
          row.push(r * size + c);
          col.push(c * size + r);
        }
        lines.push(row, col);
      }
      const d1 = [];
      const d2 = [];
      for (let i = 0; i < size; i++) {
        d1.push(i * (size + 1));
        d2.push((i + 1) * (size - 1));
      }
      lines.push(d1, d2);

      for (const line of lines) {
        const first = b[line[0]];
        if (!first) continue;
        if (line.every(i => b[i] === first)) return line;
      }
      return null;
    }

    function highlightWinningLine(){
      const line = getWinningLine(board);
      if (!line) return;
      const cells = boardEl.children;
      line.forEach(i => {
        if (cells[i]) cells[i].classList.add("win");
      });
      render();
    }

    function evaluateBoard(b) {
      const lines = [];
      for (let r = 0; r < size; r++) {
        const row = [];
        const col = [];
        for (let c = 0; c < size; c++) {
          row.push(r * size + c);
          col.push(c * size + r);
        }
        lines.push(row, col);
      }
      const d1 = [];
      const d2 = [];
      for (let i = 0; i < size; i++) {
        d1.push(i * (size + 1));
        d2.push((i + 1) * (size - 1));
      }
      lines.push(d1, d2);

      let score = 0;
      for (const line of lines) {
        let xCount = 0;
        let oCount = 0;
        for (const i of line) {
          if (b[i] === aiSymbol) xCount++;
          else if (b[i] === humanSymbol) oCount++;
        }
        if (xCount > 0 && oCount === 0) score += xCount * 2;
        else if (oCount > 0 && xCount === 0) score -= oCount * 2;
      }
      return score;
    }

    function minimaxPure(b, depth, isMaximizing, counters) {
      counters.nodesPure++;
      const w = winner(b);
      if (w === aiSymbol) return 100;
      if (w === humanSymbol) return -100;
      if (w === "DRAW") return 0;
      if (depth === 0) return evaluateBoard(b);

      if (isMaximizing) {
        let best = -Infinity;
        for (const move of availableMoves(b)) {
          b[move] = aiSymbol;
          const val = minimaxPure(b, depth - 1, false, counters);
          b[move] = EMPTY;
          best = Math.max(best, val);
        }
        return best;
      } else {
        let best = Infinity;
        for (const move of availableMoves(b)) {
          b[move] = humanSymbol;
          const val = minimaxPure(b, depth - 1, true, counters);
          b[move] = EMPTY;
          best = Math.min(best, val);
        }
        return best;
      }
    }

    function minimaxAB(b, depth, isMaximizing, alpha, beta, counters) {
      counters.nodesAB++;
      const w = winner(b);
      if (w === aiSymbol) return 100;
      if (w === humanSymbol) return -100;
      if (w === "DRAW") return 0;
      if (depth === 0) return evaluateBoard(b);

      if (isMaximizing) {
        let best = -Infinity;
        for (const move of availableMoves(b)) {
          b[move] = aiSymbol;
          const val = minimaxAB(b, depth - 1, false, alpha, beta, counters);
          b[move] = EMPTY;
          best = Math.max(best, val);
          alpha = Math.max(alpha, best);
          if (beta <= alpha) {
            counters.pruned += availableMoves(b).length;
            break;
          }
        }
        return best;
      } else {
        let best = Infinity;
        for (const move of availableMoves(b)) {
          b[move] = humanSymbol;
          const val = minimaxAB(b, depth - 1, true, alpha, beta, counters);
          b[move] = EMPTY;
          best = Math.min(best, val);
          beta = Math.min(beta, best);
          if (beta <= alpha) {
            counters.pruned += availableMoves(b).length;
            break;
          }
        }
        return best;
      }
    }

    function aiMove() {
      chipText.textContent = "Minimax is searching…";
      bannerText.textContent = "AI thinking · " + aiSymbol + " to move";
      clearInterval(turnTimer);

      setTimeout(() => {
        const counters = { nodesPure: 0, nodesAB: 0, pruned: 0 };
        let bestScore = -Infinity;
        let bestMove = null;

        const maxDepth = size === 3 ? 9 : 5; // full for 3x3, limited for 4x4

        for (const move of availableMoves(board)) {
          board[move] = aiSymbol;
          const scorePure = minimaxPure(board, maxDepth - 1, false, counters);
          const scoreAB = minimaxAB(board, maxDepth - 1, false, -Infinity, Infinity, counters);
          board[move] = EMPTY;

          const useScore = scoreAB;
          if (useScore > bestScore || bestMove === null) {
            bestScore = useScore;
            bestMove = move;
          }
        }

        nodesPureEl.textContent = counters.nodesPure;
        nodesABEl.textContent = counters.nodesAB;
        nodesPrunedEl.textContent = counters.pruned;

        board[bestMove] = aiSymbol;
        recordMove(aiSymbol, bestMove);
        playMoveSound();
        currentPlayer = humanSymbol;
        render();

        const w = winner(board);
        if (w) {
          finishGame(w);
        } else {
          chipText.textContent = "Waiting for your move";
          startTurnTimer();
        }
      }, 180);
    }

    // reason: "normal" | "timeout"
    function finishGame(result, reason = "normal") {
      gameOver = true;
      clearInterval(turnTimer);
      timerText.textContent = "";
      if (result !== "DRAW" && reason === "normal") {
        highlightWinningLine();
      } else {
        render();
      }

      if (result === "DRAW") {
        draws++;
        bannerText.textContent = "Game over · draw";
        chipText.textContent = "No winning line was found.";
        statusText.textContent = "Perfect play on 3×3 or good defence on 4×4 leads to a draw.";
        playDrawSound();
      } else if (result === humanSymbol) {
        humanWins++;
        bannerText.textContent = "Game over · you win!";
        chipText.textContent = "Human outplayed the AI.";
        statusText.textContent = "You found a better line than the search at limited depth.";
        playWinSound();
      } else if (result === aiSymbol) {
        aiWins++;
        if (reason === "timeout") {
          bannerText.textContent = "Game over · AI wins (time out)";
          chipText.textContent = "AI won because the player ran out of time twice.";
          statusText.textContent = "The timer enforces decision speed; two missed timers give the win to the AI.";
        } else {
          bannerText.textContent = "Game over · AI wins!";
          chipText.textContent = "Minimax found a winning line.";
          statusText.textContent = "AI selected the move with the best Minimax value.";
        }
        playLoseSound();
      }
      updateScoreboard();
    }

    function startTurnTimer(){
      if (symbolOverlay && !symbolOverlay.classList.contains("hidden")) return;
      clearInterval(turnTimer);
      if (gameOver || currentPlayer !== humanSymbol) {
        timerText.textContent = "";
        return;
      }
      timeLeft = 10;
      timerText.textContent = "Time left: " + timeLeft + "s  |  Miss: " + missCount + "/2";
      turnTimer = setInterval(() => {
        timeLeft--;
        if (timeLeft >= 0) {
          timerText.textContent = "Time left: " + timeLeft + "s  |  Miss: " + missCount + "/2";
        }
        if (timeLeft <= 0) {
          clearInterval(turnTimer);
          missCount++;

          // 2nd miss → AI wins by timeout
          if (missCount >= 2) {
            finishGame(aiSymbol, "timeout");
            return;
          }

          // otherwise, auto human move and continue
          autoHumanMove();
        }
      }, 1000);
    }

    function bestHumanMoveIndex(){
      const moves = availableMoves(board);
      if (!moves.length) return null;
      const maxDepth = size === 3 ? 9 : 5;
      let bestScore = Infinity;
      let bestMove = moves[0];
      const dummyCounters = {nodesPure:0, nodesAB:0, pruned:0};

      for (const move of moves){
        board[move] = humanSymbol;
        const score = minimaxAB(board, maxDepth - 1, true, -Infinity, Infinity, dummyCounters);
        board[move] = EMPTY;
        if (score < bestScore){
          bestScore = score;
          bestMove = move;
        }
      }
      return bestMove;
    }

    function autoHumanMove(){
      if (gameOver || currentPlayer !== humanSymbol) return;
      const bestMove = bestHumanMoveIndex();
      if (bestMove === null) return;

      board[bestMove] = humanSymbol;
      recordMove(humanSymbol, bestMove);
      playMoveSound();
      currentPlayer = aiSymbol;
      render();

      const w = winner(board);
      if (w) {
        finishGame(w);
      } else {
        aiMove();
      }
    }

    function showHint(){
      if (gameOver || currentPlayer !== humanSymbol) return;
      const hintIndex = bestHumanMoveIndex();
      if (hintIndex === null) return;
      // clear old hints
      const cells = boardEl.children;
      for (let i=0;i<cells.length;i++){
        cells[i].classList.remove("hint");
      }
      cells[hintIndex].classList.add("hint");
      render();
    }

    function undoLast(){
      if (gameOver) return;
      if (moveHistory.length < 2) return;
      // remove last AI move and last human move
      for (let k=0;k<2;k++){
        const last = moveHistory.pop();
        if (last){
          board[last.index] = EMPTY;
        }
      }
      currentPlayer = humanSymbol;
      renderHistory();
      render();
      startTurnTimer();
    }

    hintBtn.addEventListener("click", showHint);
    undoBtn.addEventListener("click", undoLast);

    function resetGame(resetScores = false) {
      if (resetScores) {
        humanWins = 0;
        aiWins = 0;
        draws = 0;
      }
      missCount = 0;
      moveHistory = [];
      renderHistory();
      gameOver = false;
      currentPlayer = humanSymbol;
      nodesPureEl.textContent = "0";
      nodesABEl.textContent = "0";
      nodesPrunedEl.textContent = "0";
      chipText.textContent = "Waiting for your move";
      updateSymbolTexts();
      initBoard();
      render();
      updateScoreboard();
      startTurnTimer();
    }

    resetBtn.addEventListener("click", () => resetGame(false));

    // Initial setup (overlay visible, but board ready)
    resetGame(false);
  </script>
</body>
</html>
